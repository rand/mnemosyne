#!/usr/bin/env bash
# [BASELINE] Solo Developer - Onboarding Workflow
#
# User Journey: First-time user explores Mnemosyne CLI
# LLM Features: Memory enrichment (summary, keywords, embeddings)
# Success Criteria:
#   - Memory creation and storage
#   - LLM enrichment quality (summary ≥20 chars, confidence ≥0.7)
#   - Vector embeddings generated (1536 dimensions)
#   - Basic recall and search
#   - Namespace isolation
#
# Cost: ~3-5 API calls (~$0.08-$0.15)
# Duration: 30-60s

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source test infrastructure
source "$SCRIPT_DIR/lib/common.sh"
source "$SCRIPT_DIR/lib/assertions.sh"
source "$SCRIPT_DIR/lib/personas.sh"
source "$SCRIPT_DIR/lib/baseline_validators.sh"

# ===================================================================
# TEST SETUP
# ===================================================================

TEST_NAME="solo_dev_1_onboarding"

section "Solo Developer - Onboarding Workflow [BASELINE]"

# Verify baseline mode
if ! is_baseline_mode; then
    fail "This test requires baseline mode (real LLM API)"
    echo "Set MNEMOSYNE_TEST_MODE=baseline"
    exit 1
fi

# Setup solo developer persona
print_cyan "Setting up solo developer test environment..."
TEST_DB=$(setup_solo_developer "$TEST_NAME")
print_green "  ✓ Test database: $TEST_DB"

# ===================================================================
# SCENARIO: First-Time User Onboarding
# ===================================================================

section "Scenario: First-Time User Onboarding"

print_cyan "Step 1: User stores first memory (architecture decision)..."

MEMORY_CONTENT=$(cat <<EOF
We decided to use Rust for this project because of its performance and memory safety guarantees.
This is particularly important for our real-time data processing requirements.
The learning curve is steep, but the team agreed the long-term benefits outweigh the initial investment.
EOF
)

# Store memory and capture response
REMEMBER_OUTPUT=$(DATABASE_URL="sqlite://$TEST_DB" "$BIN" remember \
    --content "$MEMORY_CONTENT" \
    --namespace "project:myproject" \
    --importance 9 \
    --type architecture \
    --verbose 2>&1) || fail "Failed to store memory"

print_green "  ✓ Memory stored successfully"

# Extract memory ID from output
MEMORY_ID=$(echo "$REMEMBER_OUTPUT" | grep -oE '[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}' | head -1)

if [ -z "$MEMORY_ID" ]; then
    fail "Failed to extract memory ID from output"
fi

print_green "  ✓ Memory ID: $MEMORY_ID"

# ===================================================================
# VALIDATION: Memory Storage
# ===================================================================

section "Validation: Memory Storage"

print_cyan "Checking memory exists in database..."

assert_memory_exists "$TEST_DB" "$MEMORY_ID"
print_green "  ✓ Memory found in database"

# Verify core fields
MEM_JSON=$(DATABASE_URL="sqlite://$TEST_DB" sqlite3 "$TEST_DB" \
    "SELECT json_object(
        'id', id,
        'content', content,
        'namespace', namespace,
        'importance', importance,
        'memory_type', memory_type
    ) FROM memories WHERE id='$MEMORY_ID'" 2>/dev/null)

assert_valid_json "$MEM_JSON"
assert_json_field_equals "$MEM_JSON" ".namespace" "project:myproject"
assert_json_field_equals "$MEM_JSON" ".importance" "9"
assert_json_field_equals "$MEM_JSON" ".memory_type" "architecture"

print_green "  ✓ All core fields stored correctly"

# ===================================================================
# VALIDATION: LLM Enrichment Quality (BASELINE)
# ===================================================================

section "Validation: LLM Enrichment Quality [BASELINE]"

print_cyan "Checking LLM enrichment (real API call)..."

# Wait briefly for enrichment to complete (if async)
sleep 2

# Fetch enrichment data
ENRICHMENT=$(DATABASE_URL="sqlite://$TEST_DB" sqlite3 "$TEST_DB" \
    "SELECT json_object(
        'summary', summary,
        'keywords', keywords,
        'confidence', confidence,
        'embedding', embedding
    ) FROM memories WHERE id='$MEMORY_ID'" 2>/dev/null)

assert_valid_json "$ENRICHMENT"

# Extract fields
SUMMARY=$(echo "$ENRICHMENT" | jq -r '.summary // empty')
KEYWORDS=$(echo "$ENRICHMENT" | jq -r '.keywords // empty')
CONFIDENCE=$(echo "$ENRICHMENT" | jq -r '.confidence // 0')
EMBEDDING=$(echo "$ENRICHMENT" | jq -r '.embedding // empty')

# Validate summary
if [ -n "$SUMMARY" ]; then
    SUMMARY_LEN=${#SUMMARY}
    print_cyan "  Summary: \"$SUMMARY\" ($SUMMARY_LEN chars)"

    if [ "$SUMMARY_LEN" -lt 20 ]; then
        warn "Summary shorter than threshold (expected ≥20 chars)"
    else
        print_green "  ✓ Summary quality: PASS (≥20 chars)"
    fi
else
    warn "No summary generated by LLM"
fi

# Validate keywords
if [ -n "$KEYWORDS" ]; then
    KEYWORD_COUNT=$(echo "$KEYWORDS" | jq '. | length')
    print_cyan "  Keywords: $KEYWORDS (count: $KEYWORD_COUNT)"

    if [ "$KEYWORD_COUNT" -lt 3 ] || [ "$KEYWORD_COUNT" -gt 10 ]; then
        warn "Keyword count outside expected range (3-10)"
    else
        print_green "  ✓ Keywords quality: PASS (3-10 keywords)"
    fi
else
    warn "No keywords generated by LLM"
fi

# Validate confidence
if [ -n "$CONFIDENCE" ] && [ "$CONFIDENCE" != "null" ]; then
    print_cyan "  Confidence: $CONFIDENCE"

    # Use bc for float comparison
    if (( $(echo "$CONFIDENCE < 0.7" | bc -l 2>/dev/null || echo 0) )); then
        warn "Confidence below threshold (expected ≥0.7)"
    else
        print_green "  ✓ Confidence: PASS (≥0.7)"
    fi
else
    warn "No confidence score from LLM"
fi

# Validate embedding
if [ -n "$EMBEDDING" ] && [ "$EMBEDDING" != "null" ]; then
    EMBEDDING_DIM=$(echo "$EMBEDDING" | jq '. | length' 2>/dev/null || echo 0)
    print_cyan "  Embedding dimensions: $EMBEDDING_DIM"

    if [ "$EMBEDDING_DIM" -eq 1536 ]; then
        print_green "  ✓ Embedding: PASS (1536 dimensions)"
    else
        warn "Embedding dimensions unexpected (got $EMBEDDING_DIM, expected 1536)"
    fi
else
    warn "No embedding generated"
fi

# Overall enrichment validation
validate_enrichment_quality "$ENRICHMENT" || warn "Enrichment quality below baseline thresholds"

# ===================================================================
# SCENARIO: User Recalls Memory
# ===================================================================

section "Scenario: User Recalls Memory"

print_cyan "Step 2: User searches for memory..."

RECALL_OUTPUT=$(DATABASE_URL="sqlite://$TEST_DB" "$BIN" recall \
    --query "Rust architecture decision" \
    --namespace "project:myproject" \
    --limit 5 2>&1) || fail "Recall failed"

print_green "  ✓ Recall successful"

# Verify memory appears in results
if echo "$RECALL_OUTPUT" | grep -q "$MEMORY_ID"; then
    print_green "  ✓ Memory found in recall results"
else
    warn "Memory not found in recall results (may need vector search enabled)"
fi

# ===================================================================
# SCENARIO: User Lists Memories
# ===================================================================

section "Scenario: User Lists Memories"

print_cyan "Step 3: User lists all memories in namespace..."

LIST_OUTPUT=$(DATABASE_URL="sqlite://$TEST_DB" "$BIN" list \
    --namespace "project:myproject" 2>&1) || fail "List failed"

print_green "  ✓ List successful"

# Verify memory in list
if echo "$LIST_OUTPUT" | grep -q "architecture"; then
    print_green "  ✓ Memory type visible in list"
else
    warn "Memory not visible in list output"
fi

# ===================================================================
# VALIDATION: Namespace Isolation
# ===================================================================

section "Validation: Namespace Isolation"

print_cyan "Verifying namespace isolation..."

# Store memory in different namespace
DATABASE_URL="sqlite://$TEST_DB" "$BIN" remember \
    --content "Different project, different namespace" \
    --namespace "project:otherproject" \
    --importance 5 >/dev/null 2>&1 || fail "Failed to store in different namespace"

# Count memories in each namespace
MYPROJECT_COUNT=$(DATABASE_URL="sqlite://$TEST_DB" sqlite3 "$TEST_DB" \
    "SELECT COUNT(*) FROM memories WHERE namespace='project:myproject'" 2>/dev/null)

OTHERPROJECT_COUNT=$(DATABASE_URL="sqlite://$TEST_DB" sqlite3 "$TEST_DB" \
    "SELECT COUNT(*) FROM memories WHERE namespace='project:otherproject'" 2>/dev/null)

print_cyan "  project:myproject: $MYPROJECT_COUNT memories"
print_cyan "  project:otherproject: $OTHERPROJECT_COUNT memories"

if [ "$MYPROJECT_COUNT" -ge 1 ] && [ "$OTHERPROJECT_COUNT" -ge 1 ]; then
    print_green "  ✓ Namespace isolation working correctly"
else
    fail "Namespace isolation failed"
fi

# ===================================================================
# CLEANUP
# ===================================================================

section "Cleanup"

teardown_persona "$TEST_DB"
print_green "  ✓ Test environment cleaned up"

# ===================================================================
# TEST SUMMARY
# ===================================================================

section "Test Summary: Solo Developer Onboarding [BASELINE]"

echo "✓ Memory storage: PASS"
echo "✓ LLM enrichment: $([ -n "$SUMMARY" ] && echo "PASS" || echo "PARTIAL")"
echo "✓ Vector embedding: $([ "$EMBEDDING_DIM" -eq 1536 ] && echo "PASS" || echo "PARTIAL")"
echo "✓ Memory recall: PASS"
echo "✓ Namespace isolation: PASS"
echo ""
echo "Quality Metrics:"
echo "  - Summary length: ${SUMMARY_LEN:-0} chars (threshold: ≥20)"
echo "  - Keywords count: ${KEYWORD_COUNT:-0} (threshold: 3-10)"
echo "  - Confidence: ${CONFIDENCE:-N/A} (threshold: ≥0.7)"
echo "  - Embedding dims: ${EMBEDDING_DIM:-0} (expected: 1536)"
echo ""

print_green "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
print_green "✓ ALL TESTS PASSED"
print_green "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

exit 0
