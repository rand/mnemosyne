[
  {
    "inputs": {
      "user_intent": "Implement user authentication with JWT tokens",
      "context": "Phase: Specification, Agent: Executor, Files: auth.rs, user.rs"
    },
    "outputs": {
      "requirements": [
        "Add login endpoint accepting email and password",
        "Hash passwords using bcrypt before storage",
        "Generate JWT access tokens on successful login",
        "Implement token validation middleware for protected routes",
        "Add token expiration with configurable lifetime",
        "Store refresh tokens for session extension"
      ],
      "priorities": [10, 9, 10, 9, 8, 7]
    },
    "metadata": {
      "source": "synthetic",
      "difficulty": "medium",
      "category": "authentication",
      "notes": "Classic authentication scenario with standard security practices"
    }
  },
  {
    "inputs": {
      "user_intent": "Add caching to improve API performance",
      "context": "Phase: Implementation, Agent: Executor, Files: api/handlers.rs, cache.rs"
    },
    "outputs": {
      "requirements": [
        "Identify cacheable API endpoints",
        "Implement cache layer with TTL support",
        "Add cache invalidation strategy",
        "Configure cache storage backend (Redis or in-memory)",
        "Measure cache hit rate and latency improvement",
        "Add cache warming for frequently accessed data"
      ],
      "priorities": [10, 10, 9, 8, 7, 6]
    },
    "metadata": {
      "source": "synthetic",
      "difficulty": "hard",
      "category": "performance",
      "notes": "Requires understanding of caching strategies and trade-offs"
    }
  },
  {
    "inputs": {
      "user_intent": "Fix the bug where users can't upload large files",
      "context": "Phase: Bug Fix, Agent: Executor, Files: upload.rs, config.rs"
    },
    "outputs": {
      "requirements": [
        "Identify root cause of upload failures for large files",
        "Increase maximum file size limit in configuration",
        "Add file size validation before upload attempt",
        "Implement chunked upload for files >10MB",
        "Add progress tracking for long uploads",
        "Test with files of various sizes (1MB, 10MB, 50MB, 100MB)"
      ],
      "priorities": [10, 9, 8, 9, 7, 8]
    },
    "metadata": {
      "source": "synthetic",
      "difficulty": "medium",
      "category": "bug_fix",
      "notes": "Bug fix scenario requiring investigation and multiple changes"
    }
  },
  {
    "inputs": {
      "user_intent": "Make the dashboard load faster",
      "context": "Phase: Optimization, Agent: Executor, Files: dashboard.tsx, api/stats.rs"
    },
    "outputs": {
      "requirements": [
        "Profile dashboard loading performance to identify bottlenecks",
        "Optimize database queries (add indexes, reduce N+1 queries)",
        "Implement lazy loading for below-the-fold content",
        "Add client-side caching for static data",
        "Paginate or virtualize large data lists",
        "Set target p95 latency goal (e.g., <500ms)"
      ],
      "priorities": [10, 9, 8, 7, 8, 10]
    },
    "metadata": {
      "source": "synthetic",
      "difficulty": "hard",
      "category": "performance",
      "notes": "Vague intent requiring clarification of performance targets"
    }
  },
  {
    "inputs": {
      "user_intent": "Add logging",
      "context": "Phase: Implementation, Agent: Executor, Files: main.rs, lib.rs"
    },
    "outputs": {
      "requirements": [
        "Define logging levels (ERROR, WARN, INFO, DEBUG)",
        "Configure logging framework (env_logger, tracing)",
        "Add structured logging with context fields",
        "Log request/response for all API endpoints",
        "Log errors with stack traces",
        "Configure log output destination (stdout, file, remote)",
        "Add log rotation policy",
        "Ensure sensitive data is not logged (passwords, tokens)"
      ],
      "priorities": [9, 10, 8, 7, 10, 8, 6, 10]
    },
    "metadata": {
      "source": "synthetic",
      "difficulty": "easy",
      "category": "infrastructure",
      "notes": "Intentionally vague to test requirement extraction from minimal intent"
    }
  },
  {
    "inputs": {
      "user_intent": "Migrate the database from SQLite to PostgreSQL",
      "context": "Phase: Refactoring, Agent: Executor, Files: database/*.rs, migrations/"
    },
    "outputs": {
      "requirements": [
        "Create PostgreSQL schema matching current SQLite schema",
        "Write data migration script to transfer existing data",
        "Update database connection configuration",
        "Modify queries using SQLite-specific features (e.g., datetime functions)",
        "Add PostgreSQL-specific optimizations (indexes, constraints)",
        "Test migration process with production-like data volumes",
        "Create rollback procedure in case of migration failure",
        "Update documentation with new database requirements"
      ],
      "priorities": [10, 10, 9, 9, 7, 10, 9, 6]
    },
    "metadata": {
      "source": "synthetic",
      "difficulty": "hard",
      "category": "database",
      "notes": "Complex migration requiring data preservation and compatibility"
    }
  },
  {
    "inputs": {
      "user_intent": "Add API versioning so we can make breaking changes without affecting existing clients",
      "context": "Phase: Architecture, Agent: Executor, Files: api/v1/, api/v2/, router.rs"
    },
    "outputs": {
      "requirements": [
        "Design versioning strategy (URL path, header, or query parameter)",
        "Create API v2 namespace/module structure",
        "Implement version routing logic",
        "Maintain v1 API for backward compatibility",
        "Define deprecation policy for old versions",
        "Add version negotiation for clients",
        "Document versioning guidelines for future changes",
        "Add tests for both v1 and v2 endpoints"
      ],
      "priorities": [10, 9, 10, 10, 8, 7, 8, 9]
    },
    "metadata": {
      "source": "synthetic",
      "difficulty": "hard",
      "category": "api_design",
      "notes": "Architectural decision with long-term maintenance implications"
    }
  },
  {
    "inputs": {
      "user_intent": "Improve error handling across the application",
      "context": "Phase: Refactoring, Agent: Executor, Files: error.rs, handlers/*.rs"
    },
    "outputs": {
      "requirements": [
        "Define consistent error types for different failure modes",
        "Add context to errors (stack traces, request IDs, user actions)",
        "Implement error recovery strategies where possible",
        "Add user-friendly error messages (not just technical details)",
        "Log errors with appropriate severity levels",
        "Return proper HTTP status codes for API errors",
        "Add error boundaries to prevent cascading failures",
        "Test error scenarios (network failures, database errors, validation errors)"
      ],
      "priorities": [10, 9, 8, 9, 10, 9, 7, 8]
    },
    "metadata": {
      "source": "synthetic",
      "difficulty": "medium",
      "category": "error_handling",
      "notes": "Systematic improvement across codebase"
    }
  },
  {
    "inputs": {
      "user_intent": "Set up continuous integration",
      "context": "Phase: Infrastructure, Agent: Executor, Files: .github/workflows/ci.yml, scripts/test.sh"
    },
    "outputs": {
      "requirements": [
        "Configure CI platform (GitHub Actions, GitLab CI, etc.)",
        "Run tests on every pull request",
        "Run linting and formatting checks",
        "Build project to verify compilation",
        "Run security vulnerability scans",
        "Generate and upload code coverage reports",
        "Add status badges to README",
        "Configure branch protection rules requiring CI pass"
      ],
      "priorities": [10, 10, 9, 9, 8, 7, 5, 9]
    },
    "metadata": {
      "source": "synthetic",
      "difficulty": "medium",
      "category": "ci_cd",
      "notes": "Infrastructure setup with multiple integration points"
    }
  },
  {
    "inputs": {
      "user_intent": "Add support for real-time notifications",
      "context": "Phase: Feature, Agent: Executor, Files: websocket.rs, notifications.rs, events.rs"
    },
    "outputs": {
      "requirements": [
        "Choose real-time transport mechanism (WebSocket, SSE, polling)",
        "Implement WebSocket connection handling",
        "Add authentication for WebSocket connections",
        "Define notification event schema and types",
        "Implement pub/sub system for broadcasting notifications",
        "Add connection state management (reconnection, heartbeat)",
        "Handle concurrent connections efficiently",
        "Add rate limiting to prevent notification spam",
        "Implement notification persistence for offline users",
        "Test with multiple concurrent connections (load testing)"
      ],
      "priorities": [10, 10, 9, 9, 9, 8, 8, 7, 8, 7]
    },
    "metadata": {
      "source": "synthetic",
      "difficulty": "hard",
      "category": "realtime",
      "notes": "Complex feature with state management and scalability concerns"
    }
  }
]
